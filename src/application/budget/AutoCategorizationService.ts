/**
 * Service for automatic categorization of transactions.
 *
 * Priority order (never overwrite higher priority sources):
 * 1. Manual (existing) - never overwrite
 * 2. Bank category (from CE/Boursorama) - source='bank', confidence=1.0
 * 3. Regex rule match - source='auto', confidence=0.8 (exact) or 0.5 (partial)
 * 4. null - no categorization found
 *
 * Generated by Ralph
 */

import type { CategoryRepository } from '@domain/budget/CategoryRepository';
import type { CategoryRule } from '@domain/budget/CategoryRule';
import {
	CategorySource,
	createTransactionCategoryAssignment,
	canOverwrite,
	type TransactionCategoryAssignment
} from '@domain/budget/TransactionCategoryAssignment';
import type { TransactionRepository } from '@domain/transaction/TransactionRepository';
import { UniqueId } from '@domain/shared/UniqueId';
import { mapBankCategory, parserProvidesCategories } from './BankCategoryMapper';
import type { ParserKey } from '@domain/import/CSVParser';

/**
 * Result of categorizing a single transaction
 */
export interface CategorizationResult {
	/** The category ID assigned, or null if no match */
	categoryId: string | null;
	/** Source of the categorization */
	source: CategorySource | null;
	/** Confidence score (0-1) */
	confidence: number;
}

/**
 * Result of categorizing all transactions
 */
export interface CategorizeAllResult {
	/** Number of transactions categorized */
	categorized: number;
	/** Number of transactions skipped (already have manual category) */
	skipped: number;
	/** Number of transactions with manual categories (preserved) */
	manual: number;
	/** Breakdown by source */
	bySource: {
		bank: number;
		auto: number;
	};
}

/**
 * Transaction data needed for categorization
 */
export interface TransactionForCategorization {
	/** Transaction ID */
	id: UniqueId;
	/** Transaction description for regex matching */
	description: string;
	/** Raw category from bank CSV (if available, e.g., from CE/Bourso) */
	rawCategory?: string;
	/** Parser key indicating source bank (for bank category mapping) */
	parserKey?: ParserKey;
}

/**
 * Service for automatic transaction categorization.
 *
 * Implements a multi-strategy approach:
 * 1. Bank categories (for CE/Boursorama that provide native categories)
 * 2. Regex rules (for Crédit Mutuel and other sources without categories)
 *
 * Never overwrites manual categorizations.
 */
export class AutoCategorizationService {
	private rulesCache: CategoryRule[] | null = null;

	constructor(
		private readonly categoryRepository: CategoryRepository,
		private readonly transactionRepository?: TransactionRepository
	) {}

	/**
	 * Categorize a single transaction.
	 *
	 * Order of priority:
	 * 1. Check if manual category exists → skip (never overwrite)
	 * 2. Try bank category mapping (if rawCategory and parserKey provided)
	 * 3. Try regex rules
	 * 4. Return null if no match
	 *
	 * @param transaction Transaction data for categorization
	 * @returns CategorizationResult with categoryId, source, and confidence
	 */
	async categorizeTransaction(
		transaction: TransactionForCategorization
	): Promise<CategorizationResult> {
		// Check existing assignment
		const existingAssignment = await this.categoryRepository.findAssignmentByTransactionId(
			transaction.id
		);

		// Never overwrite manual assignments
		if (existingAssignment?.source === CategorySource.MANUAL) {
			return {
				categoryId: existingAssignment.categoryId.toString(),
				source: CategorySource.MANUAL,
				confidence: existingAssignment.confidence
			};
		}

		// 1. Try bank category mapping first (highest confidence for non-manual)
		if (
			transaction.rawCategory &&
			transaction.parserKey &&
			parserProvidesCategories(transaction.parserKey)
		) {
			const bankResult = mapBankCategory(transaction.rawCategory, transaction.parserKey);
			if (bankResult.categoryId) {
				return {
					categoryId: bankResult.categoryId,
					source: CategorySource.BANK,
					confidence: 1.0
				};
			}
		}

		// 2. Try regex rules
		const rules = await this.getActiveRules();
		const ruleMatch = this.matchRules(transaction.description, rules);
		if (ruleMatch) {
			return {
				categoryId: ruleMatch.categoryId.toString(),
				source: CategorySource.AUTO,
				confidence: ruleMatch.confidence
			};
		}

		// 3. No categorization found
		return {
			categoryId: null,
			source: null,
			confidence: 0
		};
	}

	/**
	 * Categorize all uncategorized transactions (or re-categorize non-manual ones).
	 *
	 * For transactions without assignments: attempts categorization via rules
	 * For transactions with auto/bank assignments: re-evaluates with current rules
	 * For transactions with manual assignments: skips (preserves user choice)
	 *
	 * Note: This method only uses regex rules since rawCategory is not stored
	 * in transactions. Bank category mapping is only available at import time.
	 *
	 * @returns CategorizeAllResult with statistics
	 */
	async categorizeAll(): Promise<CategorizeAllResult> {
		const rules = await this.getActiveRules();
		const result: CategorizeAllResult = {
			categorized: 0,
			skipped: 0,
			manual: 0,
			bySource: {
				bank: 0,
				auto: 0
			}
		};

		// Get all transactions without category assignment
		const unassignedIds = await this.categoryRepository.findUnassignedTransactionIds();

		// Process each unassigned transaction
		for (const transactionId of unassignedIds) {
			// We need transaction description for regex matching
			// This requires fetching transaction data - we'll do a simplified approach
			// using just the transaction ID for now and matching via the database

			const categorization = await this.categorizeByRulesOnly(transactionId, rules);
			if (categorization) {
				const assignment = createTransactionCategoryAssignment({
					transactionId,
					categoryId: UniqueId.fromString(categorization.categoryId),
					source: CategorySource.AUTO,
					confidence: categorization.confidence
				});
				await this.categoryRepository.saveAssignment(assignment);
				result.categorized++;
				result.bySource.auto++;
			} else {
				result.skipped++;
			}
		}

		return result;
	}

	/**
	 * Categorize a single transaction and save the assignment.
	 *
	 * @param transaction Transaction data for categorization
	 * @returns The assignment created, or null if no categorization
	 */
	async categorizeAndSave(
		transaction: TransactionForCategorization
	): Promise<TransactionCategoryAssignment | null> {
		const result = await this.categorizeTransaction(transaction);

		if (!result.categoryId || !result.source) {
			return null;
		}

		// Check if we should overwrite existing
		const existing = await this.categoryRepository.findAssignmentByTransactionId(transaction.id);
		if (existing && !canOverwrite(existing, result.source)) {
			return existing;
		}

		const assignment = createTransactionCategoryAssignment({
			transactionId: transaction.id,
			categoryId: UniqueId.fromString(result.categoryId),
			source: result.source,
			confidence: result.confidence
		});

		await this.categoryRepository.saveAssignment(assignment);
		return assignment;
	}

	/**
	 * Match transaction description against active rules.
	 * Rules are already sorted by priority (highest first).
	 *
	 * @param description Transaction description
	 * @param rules Active rules sorted by priority
	 * @returns Match result or null
	 */
	private matchRules(
		description: string,
		rules: CategoryRule[]
	): { categoryId: UniqueId; confidence: number } | null {
		for (const rule of rules) {
			if (rule.matches(description)) {
				// Determine confidence based on match type
				// Exact match (simple pattern without special regex chars) = 0.8
				// Regex match (complex pattern) = 0.5
				const isSimplePattern = /^[\w\s]+$/i.test(rule.pattern);
				const confidence = isSimplePattern ? 0.8 : 0.5;

				return {
					categoryId: rule.categoryId,
					confidence
				};
			}
		}
		return null;
	}

	/**
	 * Get active rules, using cache if available.
	 */
	private async getActiveRules(): Promise<CategoryRule[]> {
		if (!this.rulesCache) {
			this.rulesCache = await this.categoryRepository.findActiveRulesByPriority();
		}
		return this.rulesCache;
	}

	/**
	 * Clear the rules cache (call after rules are modified).
	 */
	clearRulesCache(): void {
		this.rulesCache = null;
	}

	/**
	 * Categorize a transaction by rules only (for re-categorization).
	 * This is used when rawCategory is not available (stored transactions).
	 *
	 * @param transactionId Transaction ID to categorize
	 * @param rules Active rules sorted by priority
	 * @returns Categorization result or null if no match
	 */
	private async categorizeByRulesOnly(
		transactionId: UniqueId,
		rules: CategoryRule[]
	): Promise<{ categoryId: string; confidence: number } | null> {
		if (!this.transactionRepository) {
			// Without transaction repository, we cannot fetch the description
			return null;
		}

		const transaction = await this.transactionRepository.findById(transactionId);
		if (!transaction) {
			return null;
		}

		const match = this.matchRules(transaction.description, rules);
		if (match) {
			return {
				categoryId: match.categoryId.toString(),
				confidence: match.confidence
			};
		}

		return null;
	}
}
