/**
 * API endpoint for budget summary by category
 *
 * GET /api/budget/summary - returns expenses grouped by category for a period
 *
 * Query params:
 * - period: 'month' | 'last_month' | 'quarter' | 'year' (default: 'month')
 * - start_date: ISO date string (optional, for custom range)
 * - end_date: ISO date string (optional, for custom range)
 *
 * ðŸ¤– Generated by Ralph
 */

import { json } from '@sveltejs/kit';
import type { RequestHandler } from './$types';
import { CategoryRepositoryImpl } from '@infrastructure/repositories/CategoryRepository';
import { execute } from '@infrastructure/database/turso';

const categoryRepository = new CategoryRepositoryImpl();

interface CategorySummary {
	category_id: string;
	category_name: string;
	category_icon: string;
	category_color: string;
	parent_id: string | null;
	parent_name: string | null;
	transaction_count: number;
	total_amount: number;
	percentage: number;
}

interface BudgetSummaryResponse {
	period: {
		start_date: string;
		end_date: string;
		label: string;
	};
	totals: {
		expenses: number;
		income: number;
		net: number;
	};
	expenses_by_category: CategorySummary[];
	income_by_category: CategorySummary[];
	uncategorized: {
		count: number;
		total_expenses: number;
		total_income: number;
	};
}

function getDateRange(period: string): { start: Date; end: Date; label: string } {
	const now = new Date();
	const year = now.getFullYear();
	const month = now.getMonth();

	switch (period) {
		case 'last_month': {
			const lastMonth = month === 0 ? 11 : month - 1;
			const lastMonthYear = month === 0 ? year - 1 : year;
			const start = new Date(lastMonthYear, lastMonth, 1);
			const end = new Date(lastMonthYear, lastMonth + 1, 0, 23, 59, 59, 999);
			return {
				start,
				end,
				label: start.toLocaleDateString('fr-FR', { month: 'long', year: 'numeric' })
			};
		}
		case 'quarter': {
			const quarterStart = Math.floor(month / 3) * 3;
			const start = new Date(year, quarterStart, 1);
			const end = new Date(year, quarterStart + 3, 0, 23, 59, 59, 999);
			return {
				start,
				end,
				label: `T${Math.floor(month / 3) + 1} ${year}`
			};
		}
		case 'year': {
			const start = new Date(year, 0, 1);
			const end = new Date(year, 11, 31, 23, 59, 59, 999);
			return { start, end, label: year.toString() };
		}
		case 'month':
		default: {
			const start = new Date(year, month, 1);
			const end = new Date(year, month + 1, 0, 23, 59, 59, 999);
			return {
				start,
				end,
				label: start.toLocaleDateString('fr-FR', { month: 'long', year: 'numeric' })
			};
		}
	}
}

export const GET: RequestHandler = async ({ url }) => {
	const period = url.searchParams.get('period') ?? 'month';
	const customStartDate = url.searchParams.get('start_date');
	const customEndDate = url.searchParams.get('end_date');

	let startDate: Date;
	let endDate: Date;
	let label: string;

	if (customStartDate && customEndDate) {
		startDate = new Date(customStartDate);
		endDate = new Date(customEndDate);
		endDate.setHours(23, 59, 59, 999);
		label = 'PÃ©riode personnalisÃ©e';
	} else {
		const range = getDateRange(period);
		startDate = range.start;
		endDate = range.end;
		label = range.label;
	}

	const startDateStr = startDate.toISOString().split('T')[0];
	const endDateStr = endDate.toISOString().split('T')[0];

	// Get all categories for mapping
	const allCategories = await categoryRepository.findAllCategories();
	const categoryMap = new Map(allCategories.map((c) => [c.id.toString(), c]));

	// Query expenses by category (negative amounts = expenses)
	const expenseResult = await execute(
		`SELECT
			tc.category_id,
			COUNT(*) as transaction_count,
			SUM(ABS(t.amount)) as total_amount
		FROM transactions t
		INNER JOIN transaction_categories tc ON t.id = tc.transaction_id
		WHERE t.date >= ? AND t.date <= ? AND t.amount < 0
		GROUP BY tc.category_id
		ORDER BY total_amount DESC`,
		[startDateStr, endDateStr]
	);

	// Query income by category (positive amounts = income)
	const incomeResult = await execute(
		`SELECT
			tc.category_id,
			COUNT(*) as transaction_count,
			SUM(t.amount) as total_amount
		FROM transactions t
		INNER JOIN transaction_categories tc ON t.id = tc.transaction_id
		WHERE t.date >= ? AND t.date <= ? AND t.amount > 0
		GROUP BY tc.category_id
		ORDER BY total_amount DESC`,
		[startDateStr, endDateStr]
	);

	// Query uncategorized transactions
	const uncategorizedResult = await execute(
		`SELECT
			COUNT(*) as count,
			SUM(CASE WHEN t.amount < 0 THEN ABS(t.amount) ELSE 0 END) as total_expenses,
			SUM(CASE WHEN t.amount > 0 THEN t.amount ELSE 0 END) as total_income
		FROM transactions t
		LEFT JOIN transaction_categories tc ON t.id = tc.transaction_id
		WHERE t.date >= ? AND t.date <= ? AND tc.transaction_id IS NULL`,
		[startDateStr, endDateStr]
	);

	// Query totals
	const totalsResult = await execute(
		`SELECT
			SUM(CASE WHEN amount < 0 THEN ABS(amount) ELSE 0 END) as total_expenses,
			SUM(CASE WHEN amount > 0 THEN amount ELSE 0 END) as total_income
		FROM transactions
		WHERE date >= ? AND date <= ?`,
		[startDateStr, endDateStr]
	);

	const totalExpenses = (totalsResult.rows[0]?.total_expenses as number) ?? 0;
	const totalIncome = (totalsResult.rows[0]?.total_income as number) ?? 0;

	// Build expense summaries
	const expensesByCategory: CategorySummary[] = expenseResult.rows.map((row) => {
		const catId = row.category_id as string;
		const category = categoryMap.get(catId);
		const parent = category?.parentId ? categoryMap.get(category.parentId.toString()) : null;
		const totalAmount = row.total_amount as number;

		return {
			category_id: catId,
			category_name: category?.name ?? 'Unknown',
			category_icon: category?.icon ?? 'â“',
			category_color: category?.color ?? '#808080',
			parent_id: category?.parentId?.toString() ?? null,
			parent_name: parent?.name ?? null,
			transaction_count: row.transaction_count as number,
			total_amount: totalAmount,
			percentage: totalExpenses > 0 ? (totalAmount / totalExpenses) * 100 : 0
		};
	});

	// Build income summaries
	const incomeByCategory: CategorySummary[] = incomeResult.rows.map((row) => {
		const catId = row.category_id as string;
		const category = categoryMap.get(catId);
		const parent = category?.parentId ? categoryMap.get(category.parentId.toString()) : null;
		const totalAmount = row.total_amount as number;

		return {
			category_id: catId,
			category_name: category?.name ?? 'Unknown',
			category_icon: category?.icon ?? 'â“',
			category_color: category?.color ?? '#808080',
			parent_id: category?.parentId?.toString() ?? null,
			parent_name: parent?.name ?? null,
			transaction_count: row.transaction_count as number,
			total_amount: totalAmount,
			percentage: totalIncome > 0 ? (totalAmount / totalIncome) * 100 : 0
		};
	});

	const response: BudgetSummaryResponse = {
		period: {
			start_date: startDateStr,
			end_date: endDateStr,
			label
		},
		totals: {
			expenses: totalExpenses,
			income: totalIncome,
			net: totalIncome - totalExpenses
		},
		expenses_by_category: expensesByCategory,
		income_by_category: incomeByCategory,
		uncategorized: {
			count: (uncategorizedResult.rows[0]?.count as number) ?? 0,
			total_expenses: (uncategorizedResult.rows[0]?.total_expenses as number) ?? 0,
			total_income: (uncategorizedResult.rows[0]?.total_income as number) ?? 0
		}
	};

	return json(response);
};
