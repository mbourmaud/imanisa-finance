/**
 * API endpoint for managing individual category rules
 *
 * GET /api/budget/rules/[id] - returns a single rule
 * PUT /api/budget/rules/[id] - updates a rule
 * DELETE /api/budget/rules/[id] - deletes a rule
 * PATCH /api/budget/rules/[id] - toggles active state
 *
 * ü§ñ Generated by Ralph
 */

import { json, error } from '@sveltejs/kit';
import type { RequestHandler } from './$types';
import { CategoryRepositoryImpl } from '@infrastructure/repositories/CategoryRepository';
import { UniqueId } from '@domain/shared/UniqueId';
import type { RuleJSON } from '../+server';

const categoryRepository = new CategoryRepositoryImpl();

export const GET: RequestHandler = async ({ params }) => {
	const rule = await categoryRepository.findRuleById(UniqueId.fromString(params.id));
	if (!rule) {
		throw error(404, 'Rule not found');
	}

	const category = await categoryRepository.findCategoryById(rule.categoryId);

	return json({
		id: rule.id.toString(),
		category_id: rule.categoryId.toString(),
		category_name: category?.name ?? 'Unknown',
		category_icon: category?.icon ?? '‚ùì',
		category_color: category?.color ?? '#808080',
		pattern: rule.pattern,
		priority: rule.priority,
		source: rule.source,
		is_active: rule.isActive,
		created_at: rule.createdAt.toISOString()
	} as RuleJSON);
};

export const PUT: RequestHandler = async ({ params, request }) => {
	const body = await request.json();
	const { category_id, pattern, priority, source, is_active } = body as {
		category_id?: string;
		pattern?: string;
		priority?: number;
		source?: string | null;
		is_active?: boolean;
	};

	const rule = await categoryRepository.findRuleById(UniqueId.fromString(params.id));
	if (!rule) {
		throw error(404, 'Rule not found');
	}

	// Update the rule
	const updateResult = rule.update({
		pattern,
		priority,
		isActive: is_active
	});

	if (updateResult.isFailure) {
		throw error(400, updateResult.error ?? 'Failed to update rule');
	}

	// If category changed, we need to create a new rule (category is immutable in the entity)
	// For now, we'll update everything we can
	await categoryRepository.saveRule(rule);

	const category = await categoryRepository.findCategoryById(rule.categoryId);

	return json({
		id: rule.id.toString(),
		category_id: rule.categoryId.toString(),
		category_name: category?.name ?? 'Unknown',
		category_icon: category?.icon ?? '‚ùì',
		category_color: category?.color ?? '#808080',
		pattern: rule.pattern,
		priority: rule.priority,
		source: rule.source,
		is_active: rule.isActive,
		created_at: rule.createdAt.toISOString()
	} as RuleJSON);
};

export const DELETE: RequestHandler = async ({ params }) => {
	const rule = await categoryRepository.findRuleById(UniqueId.fromString(params.id));
	if (!rule) {
		throw error(404, 'Rule not found');
	}

	await categoryRepository.deleteRule(rule.id);

	return json({ success: true });
};

export const PATCH: RequestHandler = async ({ params }) => {
	const rule = await categoryRepository.findRuleById(UniqueId.fromString(params.id));
	if (!rule) {
		throw error(404, 'Rule not found');
	}

	// Toggle active state
	if (rule.isActive) {
		rule.deactivate();
	} else {
		rule.activate();
	}

	await categoryRepository.saveRule(rule);

	const category = await categoryRepository.findCategoryById(rule.categoryId);

	return json({
		id: rule.id.toString(),
		category_id: rule.categoryId.toString(),
		category_name: category?.name ?? 'Unknown',
		category_icon: category?.icon ?? '‚ùì',
		category_color: category?.color ?? '#808080',
		pattern: rule.pattern,
		priority: rule.priority,
		source: rule.source,
		is_active: rule.isActive,
		created_at: rule.createdAt.toISOString()
	} as RuleJSON);
};
