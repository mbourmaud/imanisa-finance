/**
 * Budget page server-side data loader
 * Fetches budget summary data by category for a selected period
 *
 * ðŸ¤– Generated by Ralph
 */

import type { PageServerLoad } from './$types';
import { CategoryRepositoryImpl } from '@infrastructure/repositories/CategoryRepository';
import { execute } from '@infrastructure/database/turso';

const categoryRepository = new CategoryRepositoryImpl();

export interface CategoryJSON {
	id: string;
	name: string;
	icon: string;
	color: string;
	parent_id: string | null;
	children: CategoryJSON[];
}

export interface CategorySummary {
	category_id: string;
	category_name: string;
	category_icon: string;
	category_color: string;
	parent_id: string | null;
	parent_name: string | null;
	transaction_count: number;
	total_amount: number;
	percentage: number;
}

export interface ParentCategorySummary {
	category_id: string;
	category_name: string;
	category_icon: string;
	category_color: string;
	total_amount: number;
	percentage: number;
	children: CategorySummary[];
}

export interface BudgetData {
	period: {
		start_date: string;
		end_date: string;
		label: string;
		key: string;
	};
	totals: {
		expenses: number;
		income: number;
		net: number;
	};
	expenses_by_parent: ParentCategorySummary[];
	income_by_parent: ParentCategorySummary[];
	uncategorized: {
		count: number;
		total_expenses: number;
		total_income: number;
	};
	categories: CategoryJSON[];
}

function getDateRange(
	period: string
): { start: Date; end: Date; label: string; key: string } {
	const now = new Date();
	const year = now.getFullYear();
	const month = now.getMonth();

	switch (period) {
		case 'last_month': {
			const lastMonth = month === 0 ? 11 : month - 1;
			const lastMonthYear = month === 0 ? year - 1 : year;
			const start = new Date(lastMonthYear, lastMonth, 1);
			const end = new Date(lastMonthYear, lastMonth + 1, 0, 23, 59, 59, 999);
			return {
				start,
				end,
				label: start.toLocaleDateString('fr-FR', { month: 'long', year: 'numeric' }),
				key: 'last_month'
			};
		}
		case 'quarter': {
			const quarterStart = Math.floor(month / 3) * 3;
			const start = new Date(year, quarterStart, 1);
			const end = new Date(year, quarterStart + 3, 0, 23, 59, 59, 999);
			return {
				start,
				end,
				label: `T${Math.floor(month / 3) + 1} ${year}`,
				key: 'quarter'
			};
		}
		case 'year': {
			const start = new Date(year, 0, 1);
			const end = new Date(year, 11, 31, 23, 59, 59, 999);
			return { start, end, label: year.toString(), key: 'year' };
		}
		case 'month':
		default: {
			const start = new Date(year, month, 1);
			const end = new Date(year, month + 1, 0, 23, 59, 59, 999);
			return {
				start,
				end,
				label: start.toLocaleDateString('fr-FR', { month: 'long', year: 'numeric' }),
				key: 'month'
			};
		}
	}
}

export const load: PageServerLoad = async ({ url }) => {
	const period = url.searchParams.get('period') ?? 'month';

	const range = getDateRange(period);
	const startDateStr = range.start.toISOString().split('T')[0];
	const endDateStr = range.end.toISOString().split('T')[0];

	// Get all categories for mapping and hierarchy
	const allCategories = await categoryRepository.findAllCategories();
	const categoryMap = new Map(allCategories.map((c) => [c.id.toString(), c]));

	// Build hierarchical category structure for dropdown
	const categoryJSONMap = new Map<string, CategoryJSON>();
	const rootCategories: CategoryJSON[] = [];

	for (const cat of allCategories) {
		categoryJSONMap.set(cat.id.toString(), {
			id: cat.id.toString(),
			name: cat.name,
			icon: cat.icon,
			color: cat.color,
			parent_id: cat.parentId?.toString() ?? null,
			children: []
		});
	}

	for (const cat of allCategories) {
		const catJson = categoryJSONMap.get(cat.id.toString())!;
		if (cat.parentId) {
			const parent = categoryJSONMap.get(cat.parentId.toString());
			if (parent) {
				parent.children.push(catJson);
			}
		} else {
			rootCategories.push(catJson);
		}
	}

	// Sort children and root alphabetically
	for (const cat of categoryJSONMap.values()) {
		cat.children.sort((a, b) => a.name.localeCompare(b.name, 'fr'));
	}
	rootCategories.sort((a, b) => a.name.localeCompare(b.name, 'fr'));

	// Query expenses by category (negative amounts = expenses)
	const expenseResult = await execute(
		`SELECT
			tc.category_id,
			COUNT(*) as transaction_count,
			SUM(ABS(t.amount)) as total_amount
		FROM transactions t
		INNER JOIN transaction_categories tc ON t.id = tc.transaction_id
		WHERE t.date >= ? AND t.date <= ? AND t.amount < 0
		GROUP BY tc.category_id
		ORDER BY total_amount DESC`,
		[startDateStr, endDateStr]
	);

	// Query income by category (positive amounts = income)
	const incomeResult = await execute(
		`SELECT
			tc.category_id,
			COUNT(*) as transaction_count,
			SUM(t.amount) as total_amount
		FROM transactions t
		INNER JOIN transaction_categories tc ON t.id = tc.transaction_id
		WHERE t.date >= ? AND t.date <= ? AND t.amount > 0
		GROUP BY tc.category_id
		ORDER BY total_amount DESC`,
		[startDateStr, endDateStr]
	);

	// Query uncategorized transactions
	const uncategorizedResult = await execute(
		`SELECT
			COUNT(*) as count,
			SUM(CASE WHEN t.amount < 0 THEN ABS(t.amount) ELSE 0 END) as total_expenses,
			SUM(CASE WHEN t.amount > 0 THEN t.amount ELSE 0 END) as total_income
		FROM transactions t
		LEFT JOIN transaction_categories tc ON t.id = tc.transaction_id
		WHERE t.date >= ? AND t.date <= ? AND tc.transaction_id IS NULL`,
		[startDateStr, endDateStr]
	);

	// Query totals
	const totalsResult = await execute(
		`SELECT
			SUM(CASE WHEN amount < 0 THEN ABS(amount) ELSE 0 END) as total_expenses,
			SUM(CASE WHEN amount > 0 THEN amount ELSE 0 END) as total_income
		FROM transactions
		WHERE date >= ? AND date <= ?`,
		[startDateStr, endDateStr]
	);

	const totalExpenses = (totalsResult.rows[0]?.total_expenses as number) ?? 0;
	const totalIncome = (totalsResult.rows[0]?.total_income as number) ?? 0;

	// Build expense summaries grouped by parent
	const expensesByParent = new Map<string, ParentCategorySummary>();

	for (const row of expenseResult.rows) {
		const catId = row.category_id as string;
		const category = categoryMap.get(catId);
		const totalAmount = row.total_amount as number;
		const transactionCount = row.transaction_count as number;

		// Determine parent category
		const parentCatId = category?.parentId?.toString() ?? catId;
		const parentCat = category?.parentId ? categoryMap.get(parentCatId) : category;

		if (!expensesByParent.has(parentCatId)) {
			expensesByParent.set(parentCatId, {
				category_id: parentCatId,
				category_name: parentCat?.name ?? 'Autre',
				category_icon: parentCat?.icon ?? 'â“',
				category_color: parentCat?.color ?? '#808080',
				total_amount: 0,
				percentage: 0,
				children: []
			});
		}

		const parentSummary = expensesByParent.get(parentCatId)!;

		// If this is a child category, add to children
		if (category?.parentId) {
			parentSummary.children.push({
				category_id: catId,
				category_name: category?.name ?? 'Unknown',
				category_icon: category?.icon ?? 'â“',
				category_color: category?.color ?? '#808080',
				parent_id: parentCatId,
				parent_name: parentCat?.name ?? null,
				transaction_count: transactionCount,
				total_amount: totalAmount,
				percentage: totalExpenses > 0 ? (totalAmount / totalExpenses) * 100 : 0
			});
			parentSummary.total_amount += totalAmount;
		} else {
			// It's a root category with direct transactions
			parentSummary.total_amount += totalAmount;
			// Add as a child representing "direct" transactions in this category
			parentSummary.children.push({
				category_id: catId,
				category_name: category?.name ?? 'Unknown',
				category_icon: category?.icon ?? 'â“',
				category_color: category?.color ?? '#808080',
				parent_id: null,
				parent_name: null,
				transaction_count: transactionCount,
				total_amount: totalAmount,
				percentage: totalExpenses > 0 ? (totalAmount / totalExpenses) * 100 : 0
			});
		}
	}

	// Calculate percentages for parent summaries
	for (const summary of expensesByParent.values()) {
		summary.percentage = totalExpenses > 0 ? (summary.total_amount / totalExpenses) * 100 : 0;
		// Sort children by amount descending
		summary.children.sort((a, b) => b.total_amount - a.total_amount);
	}

	// Build income summaries grouped by parent
	const incomeByParent = new Map<string, ParentCategorySummary>();

	for (const row of incomeResult.rows) {
		const catId = row.category_id as string;
		const category = categoryMap.get(catId);
		const totalAmount = row.total_amount as number;
		const transactionCount = row.transaction_count as number;

		const parentCatId = category?.parentId?.toString() ?? catId;
		const parentCat = category?.parentId ? categoryMap.get(parentCatId) : category;

		if (!incomeByParent.has(parentCatId)) {
			incomeByParent.set(parentCatId, {
				category_id: parentCatId,
				category_name: parentCat?.name ?? 'Autre',
				category_icon: parentCat?.icon ?? 'â“',
				category_color: parentCat?.color ?? '#808080',
				total_amount: 0,
				percentage: 0,
				children: []
			});
		}

		const parentSummary = incomeByParent.get(parentCatId)!;

		if (category?.parentId) {
			parentSummary.children.push({
				category_id: catId,
				category_name: category?.name ?? 'Unknown',
				category_icon: category?.icon ?? 'â“',
				category_color: category?.color ?? '#808080',
				parent_id: parentCatId,
				parent_name: parentCat?.name ?? null,
				transaction_count: transactionCount,
				total_amount: totalAmount,
				percentage: totalIncome > 0 ? (totalAmount / totalIncome) * 100 : 0
			});
			parentSummary.total_amount += totalAmount;
		} else {
			parentSummary.total_amount += totalAmount;
			parentSummary.children.push({
				category_id: catId,
				category_name: category?.name ?? 'Unknown',
				category_icon: category?.icon ?? 'â“',
				category_color: category?.color ?? '#808080',
				parent_id: null,
				parent_name: null,
				transaction_count: transactionCount,
				total_amount: totalAmount,
				percentage: totalIncome > 0 ? (totalAmount / totalIncome) * 100 : 0
			});
		}
	}

	// Calculate percentages for income parent summaries
	for (const summary of incomeByParent.values()) {
		summary.percentage = totalIncome > 0 ? (summary.total_amount / totalIncome) * 100 : 0;
		summary.children.sort((a, b) => b.total_amount - a.total_amount);
	}

	// Convert to sorted arrays
	const expensesByParentArray = Array.from(expensesByParent.values()).sort(
		(a, b) => b.total_amount - a.total_amount
	);
	const incomeByParentArray = Array.from(incomeByParent.values()).sort(
		(a, b) => b.total_amount - a.total_amount
	);

	const data: BudgetData = {
		period: {
			start_date: startDateStr,
			end_date: endDateStr,
			label: range.label,
			key: range.key
		},
		totals: {
			expenses: totalExpenses,
			income: totalIncome,
			net: totalIncome - totalExpenses
		},
		expenses_by_parent: expensesByParentArray,
		income_by_parent: incomeByParentArray,
		uncategorized: {
			count: (uncategorizedResult.rows[0]?.count as number) ?? 0,
			total_expenses: (uncategorizedResult.rows[0]?.total_expenses as number) ?? 0,
			total_income: (uncategorizedResult.rows[0]?.total_income as number) ?? 0
		},
		categories: rootCategories
	};

	return data;
};
